import Mathlib.Tactic.Basic --for Type*
import Mathlib.Data.List.Basic
import Mathlib.Data.Set.Basic
import ¬´RegEx¬ª.Language.language
import ¬´RegEx¬ª.Language.derivative
import ¬´RegEx¬ª.denotational
import ¬´RegEx¬ª.brzozowski

variable [deqùíú: DecidableEq ùíú]

/--!
# Boolean nullability

- `Œ¥` is nice however it produces regexes which are complex: Œµ ‚ãÖ Œµ, Œµ ‚ãÉ Œµ,
  which is fine denotationally, but they are not structurally equal to Œµ.

- ŒΩB is a boolean version of ŒΩ, maps a regex to true if the empty word is in the language of the regex.
  This allows us to define the membership function w ‚àà R, without quotient types on the regexes (equality modulo an equivance relation).
  Of course this approch is not at all economical, but it is a first step towards the Brzozowski derivative.
-/
@[simp]
def ŒΩB: Regex ùíú ‚Üí Bool
| Œ¶ => false
| œÑ _ => false
| e‚ÇÅ ‚ãÖ e‚ÇÇ => ŒΩB e‚ÇÅ && ŒΩB e‚ÇÇ
| e‚ÇÅ ‚ãÉ e‚ÇÇ => ŒΩB e‚ÇÅ || ŒΩB e‚ÇÇ
| _‚òÖ => true

theorem ŒΩB_correct(e: Regex ùíú): ŒΩB e = true ‚Üî [] ‚àà ‚Ñí e := by {
  induction e with
  | empty | token t => tauto
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [‚Ñí, ŒΩB]
    rw [ihe‚ÇÅ, ihe‚ÇÇ]
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [‚Ñí, ŒΩB]
    rw [ihe‚ÇÅ, ihe‚ÇÇ]
  | star e _ =>
    simp [‚Ñí, ŒΩB, eps_mem_kstar]
}

theorem ŒΩB_false(e: Regex ùíú): ŒΩB e = false ‚Üî [] ‚àâ ‚Ñí e := by {
  rw [‚ÜêŒΩB_correct]
  --exact not_iff_not_of_iff (ŒΩB_correct e)
  constructor
  . intro H
    rw [H]
    tauto
  . induction e with
    | empty | token t => tauto
    | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
      simp [ŒΩB]; tauto
    | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ => simp [ŒΩB]; tauto
    | star _ _ => simp [ŒΩB]
}
/--!
# Membership is nullable derivative
-/
def D_chain(w: Word ùíú) (r: Regex ùíú): Regex ùíú := w.foldl (Œª r c => ùíü c r) r
def brzozowski_mem(w: Word ùíú) (r: Regex ùíú): Prop := ŒΩB (D_chain w r)


def brzozowski_mem' : Word ùíú ‚Üí Regex ùíú ‚Üí Bool
  | [], R => ŒΩB R
  | h :: t, R => brzozowski_mem' t (ùíü h R)

instance brzozowski_membership': Membership (Word ùíú) (Regex ùíú) := ‚ü®brzozowski_mem‚ü©

/--! the fold version is definitionally equal to the recursive version -/
lemma brzozowski_mem'_correct: ‚àÄ (w: Word ùíú) (r: Regex ùíú), brzozowski_mem' w r = brzozowski_mem w r := by {
  intro w
  induction w with
  | nil => intro H; rfl
  | cons c w ih =>
    intro r
    simp [brzozowski_mem', brzozowski_mem, D_chain]
    rw [ih]
    rfl
}

lemma brzozowski_mem_empty(w: Word ùíú):
  w ‚àâ (Œ¶: Regex ùíú)
:= by {
  induction w with
  | nil => simp [Membership.mem, brzozowski_mem] at *
  | cons _ _ ih =>
    simp [ brzozowski_mem, ŒΩB] at *
    exact ih
}

lemma brzozowski_mem'_empty(w: Word ùíú): brzozowski_mem' w (Œ¶: Regex ùíú) = false := by {
  induction w with
  | nil => simp [brzozowski_mem'] at *
  | cons c w ih =>
    simp [ brzozowski_mem', ŒΩB] at *
    exact ih
}

lemma brzozowski_mem'_union_iff(R‚ÇÅ R‚ÇÇ : Regex ùíú) (w : Word ùíú):
  brzozowski_mem' w (R‚ÇÅ ‚ãÉ R‚ÇÇ) ‚Üî brzozowski_mem' w R‚ÇÅ ‚à® brzozowski_mem' w R‚ÇÇ
:= by {
  induction' w with a x ih generalizing R‚ÇÅ R‚ÇÇ
  case nil =>
    simp [brzozowski_mem'_empty, brzozowski_mem', D_union]
  . simp [brzozowski_mem', D_union]
    rw [ih]
}

lemma brzozowski_not_mem'_union_iff(R‚ÇÅ R‚ÇÇ : Regex ùíú) (w : Word ùíú):
  brzozowski_mem' w (R‚ÇÅ ‚ãÉ R‚ÇÇ)=false ‚Üî brzozowski_mem' w R‚ÇÅ=false ‚àß brzozowski_mem' w R‚ÇÇ=false
:= by {
  induction w generalizing R‚ÇÅ R‚ÇÇ
  case nil =>
    simp [brzozowski_mem']
  case cons c w ih =>
    simp [brzozowski_mem']
    apply ih
}

lemma brzozowski_not_mem'_empty_concat (w : Word ùíú):
  brzozowski_mem' w (Œ¶ ‚ãÖ R) = false
:= by {
  induction w generalizing R
  case nil => simp [brzozowski_mem']
  case cons c w ih =>
    simp [brzozowski_mem', Œ¥]
    rw [brzozowski_not_mem'_union_iff]
    constructor
    . exact ih
    . exact ih
}

lemma brzozowski_not_mem'_empty_concat_right (w : Word ùíú):
  brzozowski_mem' w (R ‚ãÖ Œ¶) = false
:= by {
  induction w generalizing R
  case nil => simp [brzozowski_mem']
  case cons c w ih =>
    simp [brzozowski_mem', Œ¥]
    rw [brzozowski_not_mem'_union_iff]
    constructor
    . exact ih
    . exact ih
}

lemma brzozowski_mem'_char_iff(w: Word ùíú):
  brzozowski_mem' w (œÑ c: Regex ùíú) ‚Üî w = [c]
:= by {
  cases' w with h t
  . simp [brzozowski_mem']
  cases' t with h t
  . simp [brzozowski_mem']
    split_ifs
    . tauto
    . rw [List.singleton_inj]; tauto
  . rw [brzozowski_mem', brzozowski_mem', D_token]
    split_ifs
    . rw [List.cons.injEq]
      simp [D_eps, brzozowski_mem'_empty]
      apply brzozowski_not_mem'_empty_concat
    . rw [List.cons.injEq]
      simp [D_empty, brzozowski_mem'_empty, and_false]
}

lemma brzozowski_mem'_char_delta_regex_iff(c: ùíú):
  brzozowski_mem' [c] (Œ¥ r) = false
:= by {
  simp [brzozowski_mem', ŒΩB_false]
  intro H
  sorry
}

lemma brzozowski_mem'_eps(w: Word ùíú):
  brzozowski_mem' w (Œµ: Regex ùíú) ‚Üî w = []
:= by {
  induction w with
  | nil => simp [brzozowski_mem'] at *
  | cons c w =>
    simp [ brzozowski_mem', ŒΩB] at *
    apply brzozowski_not_mem'_empty_concat
}

lemma brzozowski_mem'_d_delta (c: ùíú)(r‚ÇÅ r‚ÇÇ: Regex ùíú):
  brzozowski_mem' w (ùíü c (Œ¥ r‚ÇÅ)) = false ‚Üí brzozowski_mem' w (ùíü c (Œ¥ r‚ÇÅ)‚ãÖr‚ÇÇ) = false
:= by {
  intro _
  have hd: Œ¥ r‚ÇÅ ‚â† œÑ c := delta_ne_token r‚ÇÅ
  have h‚ÇÇ: ùíü c (Œ¥ r‚ÇÅ) = Œ¶ := by {
    sorry
  }
  rw [h‚ÇÇ]
  apply brzozowski_not_mem'_empty_concat
}

lemma brzozowski_not_mem'_delta (c: ùíú)(r: Regex ùíú) :
  brzozowski_mem' w (ùíü c (Œ¥ r)) = false
:= by {
  induction r with
  | empty | token _ =>
    simp [Œ¥, brzozowski_mem'_empty]
  | concatenation e‚ÇÅ e‚ÇÇ ih‚ÇÅ _ =>
    rw [Œ¥_concatenation]
    simp [D_concatenation]
    rw [brzozowski_not_mem'_union_iff]
    simp [brzozowski_mem'] at *
    constructor
    . apply brzozowski_mem'_d_delta c e‚ÇÅ (Œ¥ e‚ÇÇ)
      exact ih‚ÇÅ
    . have hd: Œ¥ e‚ÇÇ ‚â† œÑ c := delta_ne_token e‚ÇÇ
      have h‚ÇÇ: ùíü c (Œ¥ e‚ÇÇ) = Œ¶ := by {
        sorry
      }
      rw [h‚ÇÇ]
      apply brzozowski_not_mem'_empty_concat_right
  | union e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    rw [Œ¥_union, D_union]
    rw [brzozowski_not_mem'_union_iff]
    tauto
  | star e _ =>
    rw [Œ¥_star]
    rw [D_eps]
    rw [brzozowski_not_mem'_empty_concat]
}

lemma brzozowski_mem'_delta_iff(w: Word ùíú)(R: Regex ùíú):
  brzozowski_mem' w (Œ¥ R) = true ‚Üî w = [] ‚àß [] ‚àà ‚Ñí R
:= by {
  induction w generalizing R
  case nil =>
    simp [brzozowski_mem']
    induction R with
    | empty | token c => tauto
    | concatenation e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
      simp [Œ¥_concatenation]
      rw [ih‚ÇÅ, ih‚ÇÇ]
    | union e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
      simp [Œ¥_union]
      rw [ih‚ÇÅ, ih‚ÇÇ]
    | star e _ =>
      simp [Œ¥_star]
      apply eps_mem_kstar
  case cons h t _ =>
    constructor
    . intro H
      exfalso
      simp [brzozowski_mem'] at *
      induction R --generalizing t
      case empty =>
        simp [Œ¥_empty, brzozowski_mem',brzozowski_mem'_empty] at *
      case token ch =>
        simp [Œ¥_token, brzozowski_mem', brzozowski_mem'_empty] at *
      case concatenation e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
        simp [Œ¥_concatenation, brzozowski_mem'_union_iff] at H
        rcases H with H‚ÇÅ | H‚ÇÇ
        . sorry
        . sorry
      case union e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
        simp [Œ¥_union, brzozowski_mem', brzozowski_mem'_union_iff,  brzozowski_mem'_empty] at *
        rcases  H with H‚ÇÅ | H‚ÇÇ
        . apply ih‚ÇÅ H‚ÇÅ
        . apply ih‚ÇÇ H‚ÇÇ
      case star e _ =>
        simp [Œ¥_star, brzozowski_mem', brzozowski_mem'_empty] at *
        simp [brzozowski_not_mem'_empty_concat] at *
    . intro H
      exfalso
      simp [List.cons_inj] at H
}

lemma brzozowski_mem'_concat_iff(R‚ÇÅ R‚ÇÇ : Regex ùíú) (w : Word ùíú) :
  brzozowski_mem' w (R‚ÇÅ ‚ãÖ R‚ÇÇ) ‚Üî ‚àÉ w‚ÇÅ w‚ÇÇ, w‚ÇÅ ++ w‚ÇÇ = w ‚àß brzozowski_mem' w‚ÇÅ R‚ÇÅ ‚àß brzozowski_mem' w‚ÇÇ R‚ÇÇ
:= by {
  induction' w with a x ih generalizing R‚ÇÅ R‚ÇÇ
  case nil =>
    simp [brzozowski_mem'_empty, brzozowski_mem', D_concatenation]
    constructor
    . intro H
      exists []
      exists []
    . rintro ‚ü® w‚ÇÅ, w‚ÇÇ, hw, hm‚ÇÅ, hm‚ÇÇ‚ü©
      simp [nil_append_nil] at hw
      rw [hw.1] at hm‚ÇÅ
      rw [hw.2] at hm‚ÇÇ
      simp [brzozowski_mem'] at *
      exact And.intro hm‚ÇÅ hm‚ÇÇ
  . simp [brzozowski_mem', D_concatenation, brzozowski_mem'_union_iff]
    constructor
    . intro H
      rw [ih, ih] at H
      rcases H with ‚ü®w‚ÇÅ, w‚ÇÇ, hw, hm‚ÇÅ, hm‚ÇÇ‚ü© | ‚ü®w‚ÇÅ, w‚ÇÇ, hw, hm‚ÇÅ, hm‚ÇÇ‚ü©
      . exists a::w‚ÇÅ
        exists w‚ÇÇ
        rw [brzozowski_mem']
        exact ‚ü®by rw [‚Üêhw, List.cons_append], hm‚ÇÅ, hm‚ÇÇ‚ü©
      . exists []
        exists (a::w‚ÇÇ)
        simp [brzozowski_mem']
        rw [brzozowski_mem'_delta_iff w‚ÇÅ R‚ÇÅ] at hm‚ÇÅ
        constructor
        . rw [hm‚ÇÅ.1] at hw
          rw [nil_append_word, List.cons_inj] at *
          exact hw
        . constructor
          . rw [ŒΩB_correct]
            exact hm‚ÇÅ.2
          . exact hm‚ÇÇ
    . intro H
      rw [ih, ih]
      rcases H with ‚ü®w‚ÇÅ, w‚ÇÇ, hw, hm‚ÇÅ, hm‚ÇÇ‚ü©
      by_cases h: [] ‚àà ‚Ñí R‚ÇÅ
      . --[] ‚àà ‚Ñí R‚ÇÅ
        cases' w‚ÇÅ with b t
        . --w‚ÇÇ = []
          right
          rw [List.nil_append] at hw
          rw [hw] at hm‚ÇÇ
          exists []
          exists x
          constructor
          . tauto
          . constructor
            . -- this disappears since [] in ‚Ñí R‚ÇÅ -> [] ‚àà ŒΩB Œ¥ R‚ÇÅ
              simp [brzozowski_mem', ŒΩB_correct]
              apply Œ¥_holds
              exact h
            . exact hm‚ÇÇ
        . --w‚ÇÇ = b::t
          left
          rw [List.cons_append, List.cons_eq_cons] at hw
          refine' ‚ü®t, w‚ÇÇ, hw.2, _, hm‚ÇÇ‚ü©
          rw [‚Üêhw.1]
          exact hm‚ÇÅ
      . --[] ‚àâ ‚Ñí R‚ÇÅ
        left
        cases' w‚ÇÅ with b t
        ¬∑ rw [brzozowski_mem', ŒΩB_correct] at hm‚ÇÅ
          contradiction
        ¬∑ rw [List.cons_append, List.cons_eq_cons] at hw
          refine' ‚ü®t, w‚ÇÇ, hw.2, _, hm‚ÇÇ‚ü©
          rw [‚Üêhw.1]
          exact hm‚ÇÅ
}

lemma brzozowski_mem'_star_iff(w: Word ùíú) (R: Regex ùíú):
  brzozowski_mem' w (R‚òÖ) ‚Üî ‚àÉ a w‚ÇÅ, a::w‚ÇÅ = w ‚àß (brzozowski_mem' [a] R) ‚àß (brzozowski_mem' w‚ÇÅ (R‚òÖ))
:= by {
  simp [brzozowski_mem']

  induction R with
  | empty =>
    sorry

  | token ch => sorry
  | concatenation e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ => sorry
  | union e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ => sorry
  | star e ih => sorry
}

lemma brzozowski_mem_eps_iff(w: Word ùíú): brzozowski_mem w Œµ ‚Üî w = [] := by {
  induction w with
  | nil => simp [brzozowski_mem, ŒΩB]
  | cons c w ih =>
    simp [brzozowski_mem, ŒΩB] at *
    sorry
}

instance mem.decidable : ‚àÄ (w : Word ùíú) (R : Regex ùíú), Decidable (w ‚àà R)
  | w, Œ¶ => isFalse $ by {
    simp [Membership.mem, brzozowski_mem, D_chain];
    induction w with
    | nil => simp [D]
    | cons c w ih => simp [D]; exact ih
  }
  | w, œÑ t => by {
    induction w with
    | nil => exact Decidable.isFalse $ by simp [Membership.mem, brzozowski_mem, D_token]
    | cons c w ih =>
      simp [Membership.mem, brzozowski_mem, D_chain, D_token]
      by_cases h: c = t
      . simp [*] at *
        exact Decidable.isTrue $ by {
          rw [‚Üêh] at ih
          sorry
        }
      . simp [*] at *
        exact isFalse $ by {
          simp [*] at *
          sorry
        }
  }
  | w, e‚ÇÅ ‚ãÖ e‚ÇÇ => by {
    simp [Membership.mem, brzozowski_mem, D_chain, D_concatenation]
    sorry
  }
  | w, e‚ÇÅ ‚ãÉ e‚ÇÇ => by {
    simp [Membership.mem, brzozowski_mem, D_chain, D_union]
    sorry
  }
  | w, e‚òÖ => by {
    simp [Membership.mem, brzozowski_mem, D_chain, D_star]
    sorry
  }

example (w: Word ùíú) (r: Regex ùíú): w ‚àà r ‚Üî ŒΩB (D_chain w r) := by {
  constructor
  . intro H
    exact H
  . intro H
    exact H
}

example: [2, 3] ‚àà ((œÑ 2 ‚ãÖ œÑ 3): Regex ‚Ñï) := rfl


lemma Œµ_in_e_then_Œ¥_eq_Œµ(e: Regex ùíú): [] ‚àà ‚Ñí e ‚Üí ‚Ñí (Œ¥ e) = 1 := by {
  intro H
  rw [Œ¥_eq_ŒΩ]
  rwa [ŒΩ_eq_one_iff]
}

lemma mem_eq_delta_der(w: Word ùíú): w ‚àà ‚Ñí r ‚Üí ŒΩB (D_chain w r) := by {
  induction r with
  | empty =>
    simp [‚Ñí, D_chain, Œ¥]
    intro H
    contradiction
  | token t =>
    simp [‚Ñí, D_chain]
    intro H
    rw [H]
    --simp [*] at *
    sorry
  | concatenation e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    simp [‚Ñí, D_chain] at *
    intro H
    sorry
  | union e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    simp [‚Ñí, union_denotes]
    sorry
  | star e ih =>
    simp [‚Ñí, D_chain, D_star] at *
    intro H
    sorry
}

@[simp]
theorem mem_regex_iff_mem_language_regex (R : Regex ùíú):
  ‚àÄ w : Word ùíú, w ‚àà R ‚Üî w ‚àà ‚Ñí R
:= by {
  intro wx
  induction R --generalizing wx
  case empty => {
    constructor
    . intro H
      exfalso
      have H': wx ‚àâ Œ¶ := brzozowski_mem_empty wx
      contradiction
    . intro H
      contradiction
  }
  case token => {
    simp [‚Ñí]
    sorry
  }
  case concatenation => {
    simp [‚Ñí]
    sorry
  }
  case union => {
    simp [‚Ñí]
    sorry
  }
  case star => {
    simp [‚Ñí]
    sorry
  }
}

noncomputable instance (r: Regex ùíú): DecidablePred (¬∑ ‚àà ‚Ñí r) := fun _ ‚Ü¶
  decidable_of_iff _ (mem_regex_iff_mem_language_regex _ _)

-- #reduce ([2, 3] ‚àà ((œÑ 2 ‚ãÖ œÑ 3): Regex ‚Ñï))
-- #eval ([2, 3] ‚àà ((œÑ 2 ‚ãÖ œÑ 3): Regex ‚Ñï))
