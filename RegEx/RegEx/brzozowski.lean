import Mathlib.Tactic.Basic --for Type*
import ¬´RegEx¬ª.Language.language
import ¬´RegEx¬ª.Language.derivative
import ¬´RegEx¬ª.denotational

/--!
  # Nullability
  The nullability (`Œ¥`) maps a Regex re to Œµ if the empty word [] is in the language of r

  `Œ¥ re =`
  - `Œµ if Œµ ‚àà L re`
  - `Œ¶ otherwise`
-/
def Œ¥: Regex ùíú ‚Üí Regex ùíú
| Œ¶       => Œ¶
| œÑ _     => Œ¶
| e‚ÇÅ ‚ãÖ e‚ÇÇ => Œ¥ e‚ÇÅ ‚ãÖ Œ¥ e‚ÇÇ
| e‚ÇÅ ‚ãÉ e‚ÇÇ => Œ¥ e‚ÇÅ ‚ãÉ Œ¥ e‚ÇÇ
| _‚òÖ      => Œµ

lemma Œ¥_empty: Œ¥ (Œ¶: Regex ùíú) = Œ¶ := by simp [Œ¥]
lemma Œ¥_token: ‚àÄ c: ùíú, Œ¥ (œÑ c) = Œ¶ := by simp [Œ¥]
lemma Œ¥_union: ‚àÄ e‚ÇÅ e‚ÇÇ: Regex ùíú, Œ¥ (e‚ÇÅ ‚ãÉ e‚ÇÇ) = Œ¥ e‚ÇÅ ‚ãÉ Œ¥ e‚ÇÇ := by simp [Œ¥]
lemma Œ¥_concatenation: ‚àÄ e‚ÇÅ e‚ÇÇ: Regex ùíú, Œ¥ (e‚ÇÅ ‚ãÖ e‚ÇÇ) = Œ¥ e‚ÇÅ ‚ãÖ Œ¥ e‚ÇÇ := by simp [Œ¥]
lemma Œ¥_star: ‚àÄ e: Regex ùíú, Œ¥ (e‚òÖ) = Œµ := by simp [Œ¥]

/-
  For any Regex re, the language of (Œ¥ re) contains only the empty Word [].
-/
lemma Œ¥‚ÇÅ: ‚àÄ w: Word ùíú, w ‚àà ‚Ñí (Œ¥ r) ‚Üí w = [] := by {
  induction r with
  | empty | token _ =>
    simp [Œ¥, ‚Ñí]
    intros w H
    contradiction
  | concatenation e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    intro w
    intro concatenation
    cases w with
    | nil => rfl
    | cons w‚ÇÅ w‚ÇÇ =>
      cases concatenation with
      | intro xx Hxx =>
        cases Hxx with
        | intro yy Hyy =>
          cases Hyy with
          | intro zz Hzz =>
            cases Hzz with
            | intro tt Htt =>
            rw [‚ÜêHtt]
            specialize ih‚ÇÅ xx
            specialize ih‚ÇÇ yy
            rw [ih‚ÇÇ]
            rw [ih‚ÇÅ]
            rfl
            exact zz
            exact tt
  | union e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    intro w
    simp [Œ¥, ‚Ñí]
    specialize ih‚ÇÅ w
    specialize ih‚ÇÇ w
    intro union
    cases union with
    | inl h =>
      apply ih‚ÇÅ
      exact h
    | inr h =>
      apply ih‚ÇÇ
      exact h
  | star _ _ => simp [Œ¥]
}

/-
  If the empty word is in the language of Œ¥ re, then the empty word is in the language of the re
  `[] ‚àà L (Œ¥ r) ‚Üí [] ‚àà (L r)`
-/
lemma Œ¥‚ÇÇ: [] ‚àà ‚Ñí (Œ¥ r) ‚Üí [] ‚àà (‚Ñí r) := by {
  induction r with
  | empty =>
    simp [‚Ñí]
  | token _ =>
    simp [‚Ñí]
    intro h
    exfalso
    contradiction
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    intro H
    simp [‚Ñí] at *
    apply eps_in_each_eps_in_concat
    . apply ihe‚ÇÅ
      exact (eps_in_concat_eps_in_both (Œ¥ e‚ÇÅ) (Œ¥ e‚ÇÇ) H) |>.1
    . apply ihe‚ÇÇ
      exact (eps_in_concat_eps_in_both (Œ¥ e‚ÇÅ) (Œ¥ e‚ÇÇ) H) |>.2
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    intro H
    simp [‚Ñí] at *
    cases H with
    | inl hl =>
      apply Or.inl
      apply ihe‚ÇÅ
      exact hl
    | inr hr =>
      apply Or.inr
      apply ihe‚ÇÇ
      exact hr
  | star e _ =>
    intro _
    apply Œµ_mem_star
}

/-
  The compilation of Œ¥‚ÇÅ and Œ¥‚ÇÇ.
  The language of Œ¥ r is the singleton { [] } and [] is in the languare of r.
-/
lemma Œ¥Œµ: w ‚àà ‚Ñí (Œ¥ r) ‚Üí w = [] ‚àß [] ‚àà (‚Ñí r) := by {
  intro H
  constructor
  . apply Œ¥‚ÇÅ
    exact H
  . apply Œ¥‚ÇÇ
    have hw : w = [] := by {
      apply Œ¥‚ÇÅ
      exact H
    }
    rw [‚Üêhw]
    exact H
}

/-!
  If the empty word is in the language of r, then the empty word is in the language of Œ¥ r
-/
lemma Œ¥_holds(r: Regex ùíú): [] ‚àà ‚Ñí r ‚Üí [] ‚àà ‚Ñí (Œ¥ r) := by {
  induction r with
  | empty => simp [‚Ñí]
  | token c =>
    simp [‚Ñí]
    intro H
    exfalso
    contradiction
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    intro H
    simp [Œ¥_concatenation] at *
    exists []
    exists []
    constructor
    . apply ihe‚ÇÅ
      apply eps_in_both_eps_in_e‚ÇÅ _ e‚ÇÇ
      exact H
    . constructor
      . apply ihe‚ÇÇ
        apply eps_in_both_eps_in_e‚ÇÇ e‚ÇÅ _
        exact H
      . rfl
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    intro H
    simp [Œ¥, ‚Ñí] at *
    cases H with
    | inl hl =>
      apply Or.inl
      apply ihe‚ÇÅ
      exact hl
    | inr hr =>
      apply Or.inr
      apply ihe‚ÇÇ
      exact hr
  | star e _ =>
    intro _
    simp [Œ¥, ‚Ñí]
    rfl
}

theorem Œµ_in_Œ¥_Œµ_in_r: [] ‚àà ‚Ñí (Œ¥ r) ‚Üî [] ‚àà ‚Ñí r := by {
  constructor
  . apply Œ¥‚ÇÇ
  . apply Œ¥_holds
}

/-
 We require decidable equality for ùíú (`DecidableEq ùíú`).
 Technically, the only thing needed is a function that checks
 if a character `c` is in the set `t` captured by the token constructor `œÑ t`
 Equality is a particular case, in which the set `t` is a singleton.
 **TODO**:
 - I keep DecidableEq initially to have the first run at the proofs,
 - then I'll try to remove this constraint.
 - So in the end we will require of a letter ùíú in the token-type ùíØ `Membership ùìê ùíØ`,
`Membership ùìê ùíØ` will give us symbolic Regex, where the token will encode a set of letters, with equality as a particular case.
-/
variable [deqùíú: DecidableEq ùíú]
/-!
# Derivative of a Regular Expression
-/
def D (c: ùíú): Regex ùíú ‚Üí Regex ùíú
| Œ¶ => Œ¶
| œÑ t => if c = t then Œµ else Œ¶
| e‚ÇÅ ‚ãÖ e‚ÇÇ => (D c e‚ÇÅ ‚ãÖ e‚ÇÇ) ‚ãÉ (Œ¥ e‚ÇÅ ‚ãÖ D c e‚ÇÇ)
| e‚ÇÅ ‚ãÉ e‚ÇÇ => D c e‚ÇÅ ‚ãÉ D c e‚ÇÇ
| e‚òÖ => (D c e) ‚ãÖ (e‚òÖ)

instance: Derivative ùíú (Regex ùíú):= ‚ü®D‚ü©

@[simp]
lemma D_empty: ‚àÄ c: ùíú, ùíü c (Œ¶: Regex ùíú) = Œ¶ := Œª _ => rfl

@[simp]
lemma D_token: ‚àÄ c: ùíú, ‚àÄ t: ùíú, ùíü c (œÑ t) = if c = t then Œµ else Œ¶ := Œª _ _ => rfl

@[simp]
lemma D_concatenation: ‚àÄ c: ùíú, ‚àÄ e‚ÇÅ e‚ÇÇ: Regex ùíú,
  ùíü c (e‚ÇÅ ‚ãÖ e‚ÇÇ) = (ùíü c e‚ÇÅ ‚ãÖ e‚ÇÇ) ‚ãÉ (Œ¥ e‚ÇÅ ‚ãÖ ùíü c e‚ÇÇ) := Œª _ _ _ => rfl

@[simp]
lemma D_union: ‚àÄ c: ùíú, ‚àÄ e‚ÇÅ e‚ÇÇ: Regex ùíú, ùíü c (e‚ÇÅ ‚ãÉ e‚ÇÇ) = ùíü c e‚ÇÅ ‚ãÉ ùíü c e‚ÇÇ := Œª _ _ _ => rfl

@[simp]
lemma D_star: ‚àÄ c: ùíú, ‚àÄ e: Regex ùíú, ùíü c (e‚òÖ) = (ùíü c e) ‚ãÖ (e‚òÖ) := Œª _ _ => rfl

@[simp]
lemma D_eps: ‚àÄ (c: ùíú), ùíü c Œµ = (Œ¶: Regex ùíú)‚ãÖ(Œ¶‚òÖ) := Œª _ => rfl

theorem LD_imp_DL_token: ‚àÄ (c: ùíú) (w: Word ùíú), w ‚àà ‚Ñí (ùíü c (œÑ t)) ‚Üí w ‚àà ùíü c (‚Ñí (œÑ t)) := by {
  intros c w Hw
  simp [DerL_singleton, D_token] at *
  split
  next heq =>
    rw [‚Üêheq] at Hw
    simp [‚Ñí] at Hw
    exact Hw
  next hneq =>
    simp [*] at Hw
    exact Hw
}

lemma Œ¥_eq_ŒΩ(e: Regex ùíú):  ‚Ñí (Œ¥ e) = ŒΩ (‚Ñí e) := by {
  induction e with
  | empty =>
    simp [Œ¥, ‚Ñí, ŒΩ]
    ext w
    constructor
    . intro H
      exfalso
      exact H
    . intro H
      exfalso
      let ‚ü® hl, _ ‚ü© := H
      exact hl
  | token t =>
    simp [Œ¥, ‚Ñí, ŒΩ]
    ext w
    constructor <;> intro H
    . exfalso; exact H
    . exfalso; let ‚ü® hl, hr ‚ü© := H
      rw [hl] at hr
      contradiction
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [Œ¥, ‚Ñí, ŒΩ_concat] at *
    rw [ihe‚ÇÅ, ihe‚ÇÇ]
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [Œ¥, ‚Ñí, ŒΩ_union] at *
    rw [ihe‚ÇÅ, ihe‚ÇÇ]
  | star _ _ => simp [Œ¥, ‚Ñí, ŒΩ_star] at *

}

/-
 The correctness theorem has the form that
  The language of the derivative (`L (D c r)`) and the derivative of the language (`D c (L r)`) are the same.
  We will approach the proof by induction on the structure of the Regex r.
  Then for each case we unfold the derivative and retrieve the denotation from ‚Ñí.
  Now in the language world we simply use the lemmas defined for languages.
-/
theorem LD_eq_DL (c: ùíú) (r: Regex ùíú):
  ‚Ñí (ùíü c r) = ùíü c (‚Ñí r)
:= by {
  induction r with
  | empty =>
    simp [‚Ñí, D]
    rfl
  | token t =>
    simp [‚Ñí, D]
    simp [DerL_singleton]
    split <;> simp
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [‚Ñí, D]
    simp [DerL_concat, ‚ÜêŒ¥_eq_ŒΩ]
    rw [‚Üêihe‚ÇÅ, ‚Üêihe‚ÇÇ]
    rfl
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [‚Ñí, D]
    simp [DerL_union]
    rw [‚Üêihe‚ÇÅ, ‚Üêihe‚ÇÇ]
    rfl
  | star e ihe =>
    simp [‚Ñí, D]
    simp [DerL_star]
    rw [‚Üêihe]
    rfl
}

/--!
# Boolean nullability

- `Œ¥` is nice however it produces regexes which are complex: Œµ ‚ãÖ Œµ, Œµ ‚ãÉ Œµ,
  which is fine denotationally, but they are not structurally equal to Œµ.

- ŒΩB is a boolean version of ŒΩ, maps a regex to true if the empty word is in the language of the regex.
  This allows us to define the membership function w ‚àà R, without quotient types on the regexes (equality modulo an equivance relation).
  Of course this approch is not at all economical, but it is a first step towards the Brzozowski derivative.
-/
@[simp]
def ŒΩB: Regex ùíú ‚Üí Bool
| Œ¶ => false
| œÑ _ => false
| e‚ÇÅ ‚ãÖ e‚ÇÇ => ŒΩB e‚ÇÅ && ŒΩB e‚ÇÇ
| e‚ÇÅ ‚ãÉ e‚ÇÇ => ŒΩB e‚ÇÅ || ŒΩB e‚ÇÇ
| _‚òÖ => true

theorem ŒΩB_correct(e: Regex ùíú): ŒΩB e = true ‚Üî [] ‚àà ‚Ñí e := by {
  induction e with
  | empty | token t =>
    simp [‚Ñí, ŒΩB]
    intro H
    contradiction
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [‚Ñí, ŒΩB]
    rw [ihe‚ÇÅ, ihe‚ÇÇ]
    exact Iff.symm (eps_mem_concat_iff _ _)
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [‚Ñí, ŒΩB]
    rw [ihe‚ÇÅ, ihe‚ÇÇ, add_def]
    exact Iff.symm (eps_mem_union_iff _ _)
  | star e _ =>
    simp [‚Ñí, ŒΩB, eps_mem_kstar]
}
/--!
# Membership is nullable derivative
-/
def D_chain(w: Word ùíú) (r: Regex ùíú): Regex ùíú := w.foldl (Œª r c => ùíü c r) r
def brzozowski_mem(w: Word ùíú) (r: Regex ùíú): Prop := ŒΩB (D_chain w r)

def brzozowski_mem' : List ùíú ‚Üí Regex ùíú ‚Üí Bool
  | [], R => ŒΩB R
  | h :: t, R => brzozowski_mem' t (ùíü h R)

instance brzozowski_membership: Membership (Word ùíú) (Regex ùíú) := ‚ü®brzozowski_mem‚ü©

instance mem.decidable : ‚àÄ (w : Word ùíú) (R : Regex ùíú), Decidable (w ‚àà R)
  | w, Œ¶ => isFalse $ by {
    simp [Membership.mem, brzozowski_mem, D_chain];
    induction w with
    | nil => simp [D]
    | cons c w ih => simp [D]; exact ih
  }
  | w, œÑ t => by {
    induction w with
    | nil => exact Decidable.isFalse $ by simp [Membership.mem, brzozowski_mem, D_token]
    | cons c w ih =>
      simp [Membership.mem, brzozowski_mem, D_chain, D_token]
      by_cases h: c = t
      . simp [*] at *
        exact Decidable.isTrue $ by {
          rw [‚Üêh] at ih
          sorry
        }
      . simp [*] at *
        exact isFalse $ by {
          simp [*] at *
          sorry
        }
  }
  | w, e‚ÇÅ ‚ãÖ e‚ÇÇ => by {
    simp [Membership.mem, brzozowski_mem, D_chain, D_concatenation]
    sorry
  }
  | w, e‚ÇÅ ‚ãÉ e‚ÇÇ => by {
    simp [Membership.mem, brzozowski_mem, D_chain, D_union]
    sorry
  }
  | w, e‚òÖ => by {
    simp [Membership.mem, brzozowski_mem, D_chain, D_star]
    sorry
  }

example (w: Word ùíú) (r: Regex ùíú): w ‚àà r ‚Üî ŒΩB (D_chain w r) := by {
  constructor
  . intro H
    exact H
  . intro H
    exact H
}

example: [2, 3] ‚àà ((œÑ 2 ‚ãÖ œÑ 3): Regex ‚Ñï) := rfl


lemma Œµ_in_e_then_Œ¥_eq_Œµ(e: Regex ùíú): [] ‚àà ‚Ñí e ‚Üí ‚Ñí (Œ¥ e) = 1 := by {
  intro H
  rw [Œ¥_eq_ŒΩ]
  rwa [ŒΩ_eq_one_iff]
}

lemma mem_eq_delta_der(w: Word ùíú): w ‚àà ‚Ñí r ‚Üí ŒΩB (D_chain w r) := by {
  induction r with
  | empty =>
    simp [‚Ñí, D_chain, Œ¥]
    intro H
    contradiction
  | token t =>
    simp [‚Ñí, D_chain]
    intro H
    rw [H]
    simp [*] at *
  | concatenation e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    simp [‚Ñí, D_chain] at *
    intro H
    sorry
  | union e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    simp [‚Ñí, union_denotes]
    sorry
  | star e ih =>
    simp [‚Ñí, D_chain, D_star] at *
    intro H
    sorry
}

@[simp]
theorem mem_regex_iff_mem_language_regex (R : Regex ùíú):
  ‚àÄ w : Word ùíú, w ‚àà R ‚Üî w ‚àà ‚Ñí R
:= by {
  intro wx
  induction R generalizing wx
  case empty => {
    simp [‚Ñí]
    sorry
  }
  case token => {
    simp [‚Ñí]
    sorry
  }
  case concatenation => {
    simp [‚Ñí]
    sorry
  }
  case union => {
    simp [‚Ñí]
    sorry
  }
  case star => {
    simp [‚Ñí]
    sorry
  }
}

instance (r: Regex ùíú): DecidablePred (¬∑ ‚àà ‚Ñí r) := fun _ ‚Ü¶
  decidable_of_iff _ (mem_regex_iff_mem_language_regex _ _)

-- #eval ([2, 3] ‚àà ((œÑ 2 ‚ãÖ œÑ 3): Regex ‚Ñï))
