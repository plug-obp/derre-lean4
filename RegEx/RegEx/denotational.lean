import Mathlib.Init.Set
import Mathlib.Tactic.Basic --for Type*
import Mathlib.Tactic.Tauto
import Mathlib.Tactic.PushNeg
import Mathlib.Tactic.LibrarySearch

/-!
# Inspired by

- [Regular-expression derivatives reexamined](https://www.khoury.northeastern.edu/home/turon/re-deriv.pdf)
- [regex-derivative @ Tej Chajed](https://github.com/tchajed/regex-derivative/blob/master/regex.v)
-/

-- The ùíúlphabet
variable
  { ùíú : Type* } -- ùíú because we cannot use Œ£

/-!
  # Standard names
  These simple definitions give standard names from the theory of computation to
  the analogues in this setting.
-/

/-!
  A word takes elements from the (arbitrary) alphabet above. *)
  **TODO**: I think that list is too restrictive,
    we need LinearOrder here or something similar
  Basically a word should be a linear order on a subset of ùíú
    LinearOrder X, where X ‚äÜ ùíú
  Since ùíú is a type, X might be a subtype
-/
alias Word := List
instance: HAppend (Word ùíú) (Word ùíú) (Word ùíú) := ‚ü® List.append ‚ü©
instance: HAppend (Word ùíú) (List ùíú) (Word ùíú) := ‚ü® List.append ‚ü©
instance: HAppend (List ùíú) (Word ùíú) (Word ùíú) := ‚ü® List.append ‚ü©

@[simp]
lemma word_append_nil: ‚àÄ w: Word ùíú, w ++ ([]: List ùíú) = w := by {
  intro w
  apply List.append_nil w
}

@[simp]
lemma nil_append_word: ‚àÄ w: Word ùíú, ([]: List ùíú) ++ w = w := by {
  intro w
  apply List.nil_append w
}

/-!
A language is a set of words over an alphabet ùíú.
As usual a set is a T ‚Üí Prop, so in our case  (Word ùíú) ‚Üí Prop
-/

def Language ùíú := Set $ Word ùíú
instance: Membership (Word ùíú) (Language ùíú) := ‚ü®Set.Mem‚ü©
instance: EmptyCollection (Language ùíú) := ‚ü® Œª _ => False ‚ü©
instance: Union (Language ùíú) := ‚ü®Set.union‚ü©

def singleWord (w: Word ùíú) : Language ùíú := {b : Word ùíú | b = w}
instance: Singleton (Word ùíú) (Language ùíú) := ‚ü®singleWord‚ü©
def singleLetter[Singleton (Word ùíú) (Language ùíú)] (w: ùíú) : Language ùíú := {[w]}
instance [Singleton (Word ùíú) (Language ùíú)]: Singleton ùíú (Language ùíú) := ‚ü®singleLetter‚ü©


instance: HasSubset $ Language ùíú := ‚ü®Set.Subset‚ü©

inductive Regex ùíú :=
| empty
| token         (c: ùíú)
| concatenation (e‚ÇÅ e‚ÇÇ : Regex ùíú)
| union         (e‚ÇÅ e‚ÇÇ : Regex ùíú)
| star          (e : Regex ùíú)
deriving DecidableEq, Inhabited

 instance: EmptyCollection (Regex ùíú) := ‚ü® .empty ‚ü©

-- open Regex

notation:100 "Œ¶"    => Regex.empty
prefix:80    "œÑ"    => Regex.token
infixl:65    " ‚ãÉ "  => Regex.union
infixl:70    "‚ãÖ"    => Regex.concatenation
postfix:65   "‚òÖ"    => Regex.star

-- Œµ is a derived regex that matches only the empty string
def Œµ: Regex ùíú := .star .empty

/--!
  # Denotational definition of star
  We need this inductive definition to side-step the termination checker
  for the denotational semantics.
  The language of ‚òÖ is defined as:
  `L e‚òÖ = {[]} ‚à™ L (e ¬∑ e‚òÖ)`
  but this does not work as a recursive definition because `L e‚òÖ` needs `L e‚òÖ`
  which diverges, which is normal since a regular expression
  can represent languages with infinitely many words
-/
inductive star (l: Language ùíú) : Language ùíú
| star_empty: star l []
| star_iter: ‚àÄ w‚ÇÅ w‚ÇÇ,
      (w‚ÇÅ ‚àà l) ‚Üí star l w‚ÇÇ
      ‚Üí------------------
      star l (w‚ÇÅ ++ w‚ÇÇ)

/--!
  # The denotational semantics of a regex is a language
-/
def L: Regex ùíú ‚Üí Language ùíú
| Œ¶       => ‚àÖ
| œÑ c     => { [c] }
| e‚ÇÅ ‚ãÖ e‚ÇÇ => { w | ‚àÉ w‚ÇÅ w‚ÇÇ, w‚ÇÅ ‚àà L e‚ÇÅ ‚àß w‚ÇÇ ‚àà L e‚ÇÇ ‚àß w = w‚ÇÅ ++ w‚ÇÇ}
| e‚ÇÅ ‚ãÉ e‚ÇÇ => L e‚ÇÅ ‚à™ L e‚ÇÇ
| e‚òÖ      => { w | w ‚àà star (L e) }

/--!
To write the correctness of the regex derivatiev, `DerL` defines derivative for a language (denotation side).
The derivative of a language L wrt a character c is the set of all words w for which c‚ãÖw is in L
-/
def DerL (c: ùíú) (L: Language ùíú) : Language ùíú := { w | (c :: w) ‚àà L }

lemma star_emptyL: star ‚àÖ w ‚Üí w = [] := by {
  intro H
  cases H with
  | star_empty => rfl
  | star_iter w‚ÇÅ w‚ÇÇ w‚ÇÅ_in_empty _ =>
    exfalso
    apply w‚ÇÅ_in_empty
}


-- Œµ represents the language consisting only of the empty word.
lemma words_in_L_Œµ (w: Word ùíú): w ‚àà L Œµ ‚Üî w = [] := by {
  constructor
  . apply star_emptyL
  . intro wH
    rw [wH]
    simp [L]
    apply star.star_empty
}

-- The language of Œµ is the singleton set { [] }
--  L Œµ = { [] }
def LŒµ : Language ùíú  := { [] }

lemma eps_denotation: @L ùíú Œµ = {[]} := by {
  apply funext
  intro w
  apply propext
  apply words_in_L_Œµ
}

/--!

Equalities

-/

@[simp]
lemma L_empty: L (Œ¶: Regex ùíú) = ‚àÖ := by {
  apply funext
  intro w
  apply propext
  simp [L]
}

@[simp]
lemma L_token: ‚àÄ c: ùíú, L (œÑ c) = {[c]} := by {
  intro c
  apply funext
  intro w
  apply propext
  simp [L]
}

@[simp]
lemma L_union: ‚àÄ e‚ÇÅ e‚ÇÇ: Regex ùíú, L (e‚ÇÅ ‚ãÉ e‚ÇÇ) = L e‚ÇÅ ‚à™ L e‚ÇÇ := by {
  intros e‚ÇÅ e‚ÇÇ
  apply funext
  intro w
  apply propext
  simp [L]
}

lemma L_concatenation: ‚àÄ e‚ÇÅ e‚ÇÇ: Regex ùíú, L (e‚ÇÅ ‚ãÖ e‚ÇÇ) = { w | ‚àÉ w‚ÇÅ w‚ÇÇ, w‚ÇÅ ‚àà L e‚ÇÅ ‚àß w‚ÇÇ ‚àà L e‚ÇÇ ‚àß w = w‚ÇÅ ++ w‚ÇÇ} := by {
  intros e‚ÇÅ e‚ÇÇ
  apply funext
  intro w
  apply propext
  simp [L]
}

lemma L_star: ‚àÄ e: Regex ùíú, L (e‚òÖ) = { w | w ‚àà star (L e) } := by {
  intro e
  apply funext
  intro w
  apply propext
  simp [L]
}

@[simp]
lemma LŒµ_star: @L ùíú (Œµ‚òÖ) = LŒµ := by {
  apply funext
  intro w
  apply propext
  simp [L]
  sorry
}

@[simp]
lemma Œµ_concatenation: ‚àÄ e: Regex ùíú, L (Œµ ‚ãÖ e) = L e := by {
  intro e
  apply funext
  intro w
  apply propext
  simp [L]
  sorry
}

@[simp]
lemma concatenation_Œµ: ‚àÄ e: Regex ùíú, L (e ‚ãÖ Œµ) = L e := by {
  sorry
}

@[simp]
lemma Œ¶_concatenation: ‚àÄ e: Regex ùíú, L (Œ¶ ‚ãÖ e) = ‚àÖ := by {
  intro e
  apply funext
  intro w
  apply propext
  simp [L]
  sorry
}

@[simp]
lemma concatenation_Œ¶: ‚àÄ e: Regex ùíú, L (e ‚ãÖ Œ¶) = ‚àÖ := by {
  intro e
  apply funext
  intro w
  apply propext
  simp [L]
  sorry
}

lemma concatenation_assoc: ‚àÄ e‚ÇÅ e‚ÇÇ e‚ÇÉ: Regex ùíú, L ((e‚ÇÅ ‚ãÖ e‚ÇÇ) ‚ãÖ e‚ÇÉ) = L (e‚ÇÅ ‚ãÖ (e‚ÇÇ ‚ãÖ e‚ÇÉ)) := by {
  intros e‚ÇÅ e‚ÇÇ e‚ÇÉ
  apply funext
  intro w
  apply propext
  sorry
}

@[simp]
lemma empty_union_e: ‚àÄ e: Regex ùíú, L (Œ¶ ‚ãÉ e) = L e := by {
  intro e
  apply funext
  intro w
  apply propext
  simp [L]
  constructor
  . intro H
    cases H with
    | inl Hl => exfalso; exact Hl
    | inr Hr => exact Hr
  . intro H
    apply Or.inr
    exact H
}

@[simp]
lemma union_idempotent: ‚àÄ e: Regex ùíú, L (e ‚ãÉ e) = L e := by {
  intro e
  apply funext
  intro w
  apply propext
  simp [*]
  constructor
  . intro H
    cases H with
    | inl Hl => exact Hl
    | inr Hr => exact Hr
  . intro H
    apply Or.inr
    exact H
}

lemma union_comm: ‚àÄ r‚ÇÅ r‚ÇÇ: Regex ùíú, L (r‚ÇÅ ‚ãÉ r‚ÇÇ) = L (r‚ÇÇ ‚ãÉ r‚ÇÅ) := by {
  intros r‚ÇÅ r‚ÇÇ
  apply funext
  intro w
  apply propext
  simp [L]
  constructor
  . intro H
    cases H with
    | inl Hl => apply Or.inr; exact Hl
    | inr Hr => apply Or.inl; exact Hr
  . intro H
    cases H with
    | inl Hl => apply Or.inr; exact Hl
    | inr Hr => apply Or.inl; exact Hr
}

lemma union_assoc: ‚àÄ r‚ÇÅ r‚ÇÇ r‚ÇÉ: Regex ùíú, L ((r‚ÇÅ ‚ãÉ r‚ÇÇ) ‚ãÉ r‚ÇÉ) = L (r‚ÇÅ ‚ãÉ (r‚ÇÇ ‚ãÉ r‚ÇÉ)) := by {
  intros r‚ÇÅ r‚ÇÇ r‚ÇÉ
  apply funext
  intro w
  apply propext
  simp [L]
  sorry
}

@[simp]
lemma union_empty: ‚àÄ r: Regex ùíú, L (r ‚ãÉ Œ¶) = L r := by {
  intro r
  apply funext
  intro w
  apply propext
  simp [L]
  constructor
  . intro H
    cases H with
    | inl Hl => exact Hl
    | inr Hr => exfalso; exact Hr
  . intro H
    apply Or.inl
    exact H
}

@[simp]
lemma union_empty': ‚àÄ r: Regex ùíú, L (Œ¶ ‚ãÉ r) = L r := by {
  intro r
  rw [union_comm]
  apply union_empty
}

@[simp]
lemma star_star: ‚àÄ e: Regex ùíú, L (e‚òÖ‚òÖ) = L (e‚òÖ) := by {
  intro e
  apply funext
  intro w
  apply propext
  simp [L]
  constructor
  . intro H
    cases H with
    | star_empty =>
      apply star.star_empty
    | star_iter w‚ÇÅ w‚ÇÇ w‚ÇÅ_in_e hw‚ÇÇ =>
      cases hw‚ÇÇ with
      | star_empty =>
        conv in (w‚ÇÅ ++ []) => apply word_append_nil
        exact w‚ÇÅ_in_e
      | star_iter w‚ÇÉ w‚ÇÑ w‚ÇÉ_in_e hw‚ÇÑ =>
        apply star.star_iter
        . sorry
        . sorry
  . intro H
    cases H with
    | star_empty =>
      apply star.star_empty
    | star_iter w‚ÇÅ w‚ÇÇ w‚ÇÅ_in_e hw‚ÇÇ =>
      apply star.star_iter
      . sorry
      . sorry
}


/--!
  # Nullability
  The nullability (`Œ¥`) maps a Regex re to Œµ if the empty word [] is in the language of r

  `Œ¥ re =`
  - `Œµ if Œµ ‚àà L re`
  - `Œ¶ otherwise`
-/
def Œ¥: Regex ùíú ‚Üí Regex ùíú
| Œ¶       => Œ¶
| œÑ _     => Œ¶
| e‚ÇÅ ‚ãÖ e‚ÇÇ => Œ¥ e‚ÇÅ ‚ãÖ Œ¥ e‚ÇÇ
| e‚ÇÅ ‚ãÉ e‚ÇÇ => Œ¥ e‚ÇÅ ‚ãÉ Œ¥ e‚ÇÇ
| _‚òÖ      => Œµ

/-
  For any Regex re, the language of (Œ¥ re) contains only the empty Word [].
-/
lemma Œ¥‚ÇÅ: ‚àÄ w: Word ùíú, w ‚àà L (Œ¥ r) ‚Üí w = [] := by {
  induction r with
  | empty | token _ =>
    simp [Œ¥, L]
    intros w H
    contradiction
  | concatenation e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    intro w
    intro concatenation
    cases w with
    | nil => rfl
    | cons w‚ÇÅ w‚ÇÇ =>
      cases concatenation with
      | intro xx Hxx =>
        cases Hxx with
        | intro yy Hyy =>
          cases Hyy with
          | intro zz Hzz =>
            cases Hzz with
            | intro tt Htt =>
            rw [Htt]
            specialize ih‚ÇÅ xx
            specialize ih‚ÇÇ yy
            simp [*] at *
            rw [ih‚ÇÅ]
            rw [ih‚ÇÇ]
            rfl
  | union e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    intro w
    simp [Œ¥, L]
    specialize ih‚ÇÅ w
    specialize ih‚ÇÇ w
    intro union
    cases union with
    | inl h =>
      apply ih‚ÇÅ
      exact h
    | inr h =>
      apply ih‚ÇÇ
      exact h
  | star e _ =>
    simp [Œ¥]
    intros w h
    rw [‚Üêwords_in_L_Œµ]
    exact h
}

/-
  If the empty word is in the language of Œ¥ re, then the empty word is in the language of the re
  `[] ‚àà L (Œ¥ r) ‚Üí [] ‚àà (L r)`
-/
lemma Œ¥‚ÇÇ: [] ‚àà L (Œ¥ r) ‚Üí [] ‚àà (L r) := by {
  induction r with
  | empty =>
    simp [L]
  | token _ =>
    simp [L]
    intro h
    exfalso
    contradiction
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    intro H
    simp [L] at *
    cases H with
    | intro x Hx =>
      cases Hx with
      | intro y Hy =>
        cases Hy with
        | intro z Hz =>
          exists []
          constructor
          . apply ihe‚ÇÅ
            have hx : x = [] := by {
              apply Œ¥‚ÇÅ
              exact y
            }
            rw [‚Üêhx]
            exact y
          . exists []
            constructor
            . apply ihe‚ÇÇ
              have hz : z = [] := by {
                apply Œ¥‚ÇÅ
                exact Hz.left
              }
              rw [‚Üêhz]
              exact Hz.left
            . rfl
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    intro H
    simp [L] at *
    cases H with
    | inl hl =>
      apply Or.inl
      apply ihe‚ÇÅ
      exact hl
    | inr hr =>
      apply Or.inr
      apply ihe‚ÇÇ
      exact hr
  | star e _ =>
    intro _
    apply star.star_empty
}

/-
  The compilation of Œ¥‚ÇÅ and Œ¥‚ÇÇ.
  The language of Œ¥ r is the singleton { [] } and [] is in the languare of r.
-/
lemma Œ¥Œµ: w ‚àà L (Œ¥ r) ‚Üí w = [] ‚àß [] ‚àà (L r) := by {
  intro H
  constructor
  . apply Œ¥‚ÇÅ
    exact H
  . apply Œ¥‚ÇÇ
    have hw : w = [] := by {
      apply Œ¥‚ÇÅ
      exact H
    }
    rw [‚Üêhw]
    exact H
}

lemma he1 : ‚àÄ x z : Word ùíú, [] = x ++ z ‚Üí x = [] ‚àß z = [] := by {
  intros x y
  cases x with
  | nil => tauto
  | cons h t =>
    tauto
}

/-!
  If the empty word is in the language of r, then the empty word is in the language of Œ¥ r
-/
lemma Œ¥_holds: [] ‚àà L r ‚Üí [] ‚àà L (Œ¥ r) := by {
  induction r with
  | empty => simp [L]
  | token c =>
    simp [L]
    intro H
    exfalso
    contradiction
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    intro H
    simp [L] at *
    cases H with
    | intro x Hx =>
      cases Hx with
      | intro y Hy =>
        cases Hy with
        | intro z Hz =>
          have hx : x = [] ‚àß z = [] := by {
            cases Hz with
            | intro lh rh =>
              apply he1
              exact rh
          }
          exists []
          constructor
          . apply ihe‚ÇÅ
            rw [hx.left] at y
            exact y
          . exists []
            constructor
            . apply ihe‚ÇÇ
              cases Hz with
              | intro hl hr =>
                rw [hx.right] at hl
                exact hl
            . rfl
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    intro H
    simp [Œ¥, L] at *
    cases H with
    | inl hl =>
      apply Or.inl
      apply ihe‚ÇÅ
      exact hl
    | inr hr =>
      apply Or.inr
      apply ihe‚ÇÇ
      exact hr
  | star e _ =>
    intro _
    apply star.star_empty
}

theorem Œ¥_empty: [] ‚àà L (Œ¥ r) ‚Üî [] ‚àà L r := by {
  constructor
  . apply Œ¥‚ÇÇ
  . apply Œ¥_holds
}

/-
 We require decidable equality for ùíú (`DecidableEq ùíú`).
 Technically, the only thing needed is a function that checks
 if a character `c` is in the set `t` captured by the token constructor `œÑ t`
 Equality is a particular case, in which the set `t` is a singleton.
 **TODO**:
 - I keep DecidableEq initially to have the first run at the proofs,
 - then I'll try to remove this constraint.
 - So in the end we will require of a letter ùíú in the token-type ùíØ `Membership ùìê ùíØ`,
`Membership ùìê ùíØ` will give us symbolic Regex, where the token will encode a set of letters, with equality as a particular case.
-/
variable [deqùíú: DecidableEq ùíú]
/-!
# Derivative of a Regular Expression
-/
def D (c: ùíú): Regex ùíú ‚Üí Regex ùíú
| Œ¶ => Œ¶
| œÑ t => if t = c then Œµ else Œ¶
| e‚ÇÅ ‚ãÖ e‚ÇÇ => (D c e‚ÇÅ ‚ãÖ e‚ÇÇ) ‚ãÉ (Œ¥ e‚ÇÅ ‚ãÖ D c e‚ÇÇ)
| e‚ÇÅ ‚ãÉ e‚ÇÇ => D c e‚ÇÅ ‚ãÉ D c e‚ÇÇ
| e‚òÖ => D c e ‚ãÖ e‚òÖ

/-
 The correctness theorem has the form that
  The language of the derivative (`L (D c re)`) and the derivative of the language (`D c (L re)`) are the same.
  That is `‚àÄ w, w ‚àà L (D c re) ‚Üî w ‚àà D c (L re)`

  We will approach this proof by stating and proving separate lemmas for each direction of the bi-implication
  This will get us:
  1. L (D c re) ‚äÜ D c (L re)
  2. D c (L re) ‚äÜ L (D c re)
  3. thus L (D c re) = D c (L re)
-/

theorem LD_imp_DL: ‚àÄ w: Word ùíú,  w ‚àà L (D c re) ‚Üí w ‚àà DerL c (L re) := by {
  intro w‚ÇÅ

  induction re with
  | empty =>
    simp [L]
    tauto
  | token t =>
    simp [D, L, DerL]
    intro Hw‚ÇÅ
    sorry

  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ => sorry
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [L, DerL] at *
    intro H
    cases H with
    | inl Hw =>
      apply Or.inl
      apply ihe‚ÇÅ
      exact Hw
    | inr Hw =>
      apply Or.inr
      apply ihe‚ÇÇ
      exact Hw
  | star e ihe =>
    simp [DerL] at *
    intro Hw
    cases Hw with
    | star_empty => sorry
    | star_iter w‚ÇÅ w‚ÇÇ w‚ÇÅ_in_e hw‚ÇÇ =>
      sorry
}

theorem DL_imp_LD: ‚àÄ w: Word ùíú, w ‚àà DerL c (L re) ‚Üí w ‚àà L (D c re) := by {
  intros w‚ÇÅ hw‚ÇÅ
  simp [DerL] at *
  induction re with
  | empty =>
    simp [L, D]
    tauto
  | token t =>
    simp [L, D]
    cases hw‚ÇÅ
    simp [*]
    rw [words_in_L_Œµ]
  | concatenation e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ => sorry
  | union e‚ÇÅ e‚ÇÇ ihe‚ÇÅ ihe‚ÇÇ =>
    simp [L, D] at *
    cases hw‚ÇÅ with
    | inl hw =>
      apply Or.inl
      apply ihe‚ÇÅ
      exact hw
    | inr hw =>
      apply Or.inr
      apply ihe‚ÇÇ
      exact hw
  | star e ihe =>
    simp [D] at *
    sorry
}

theorem LD_iff_DL: ‚àÄ w: Word ùíú,  w ‚àà L (D c re) ‚Üî w ‚àà DerL c (L re) := by {
  intro w
  constructor
  apply LD_imp_DL
  apply DL_imp_LD
}

theorem LD_sseq_DL (c: ùíú): L (D c re) ‚äÜ DerL c (L re) := by {
  apply LD_imp_DL
}

theorem DL_sseq_LD (c: ùíú): DerL c (L re) ‚äÜ L (D c re) := by {
  apply DL_imp_LD
}

theorem LD_eq_DL (c: ùíú): L (D c re) = DerL c (L re) := by {
  apply Set.ext
  apply LD_iff_DL
}
